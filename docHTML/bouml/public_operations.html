<!-- Documentation produced by the Html generator of Bouml (http://bouml.free.fr) -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Public Operations Index</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body bgcolor="#ffffff">

<div class = "title">Public Operations Index</div>
<p></p>

<!-- ============================================================= -->

<table>
<tr bgcolor=#f0f0f0><td align=center><b>Operation</b></td><td align=center><b>Class</b></td><td align=center><b>Description</b></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation144771"><b>allocateOneRegister</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td> allocate a register different from r1 and r2</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation144515"><b>allocateOneRegister</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation144643"><b>allocateOneRegister</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td> allocate a register different from r1</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation144899"><b>allocateRegisters</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td>Allocate three registers for a 3-addresses opcode</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128515.html#refoperation131075"><b>append</b></a></td><td><a href="class128515.html#refclass128515"><b>Code3a</b></a></td><td>Add a statement at the end of the list of TAC.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128515.html#refoperation130819"><b>append</b></a></td><td><a href="class128515.html#refclass128515"><b>Code3a</b></a></td><td>Appends two codes. Lists of instructions are concatenated. The two lists<br />of string constants used in each code are also concatenated.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128515.html#refoperation130947"><b>appendData</b></a></td><td><a href="class128515.html#refclass128515"><b>Code3a</b></a></td><td>Add a Data3a for storing a string constant</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation161283"><b>argument_list</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "argument_list"<br /> ./src/VSLParser.g:94:1: argument_list : expression ( COM ! expression )* ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation165763"><b>argument_list</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "primary_exp"<br /> $ANTLR start "argument_list"<br /> ./src/VSLTreeParser.g:273:1: argument_list[SymbolTable symTab, FunctionType fType] returns [Code3a code] : (e= expression[symTab] )* ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation166659"><b>array_declaration</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "item_declaration"<br /> $ANTLR start "array_declaration"<br /> ./src/VSLTreeParser.g:362:1: array_declaration[SymbolTable symTab] returns [Code3a code] : ^( ARDECL IDENT d= INTEGER ) ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation160003"><b>array_elem</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "array_elem"<br /> ./src/VSLParser.g:70:1: array_elem : IDENT LB expression RB -&gt; ^( ARELEM IDENT expression ) ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation165251"><b>array_elem</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "assign_lhs"<br /> $ANTLR start "array_elem"<br /> ./src/VSLTreeParser.g:190:1: array_elem[SymbolTable symTab, ExpAttribute rhsExp] returns [ExpAttribute lhsExp] : ^( ARELEM IDENT indexExp= expression[symTab] ) ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128131.html#refoperation128899"><b>ArrayType</b></a></td><td><a href="class128131.html#refclass128131"><b>ArrayType</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation165123"><b>assign_lhs</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "statement"<br /> $ANTLR start "assign_lhs"<br /> ./src/VSLTreeParser.g:168:1: assign_lhs[SymbolTable symTab, ExpAttribute rhsExp] returns [ExpAttribute lhsExp] : ( IDENT |ae= array_elem[symTab, rhsExp] );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation159747"><b>block</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "block"<br /> ./src/VSLParser.g:65:1: block : ( LC declaration inst_list RC -&gt; ^( BLOCK declaration inst_list ) | LC inst_list RC -&gt; ^( BLOCK inst_list ) );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation164867"><b>body</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "param"<br /> $ANTLR start "body"<br /> ./src/VSLTreeParser.g:98:1: body[SymbolTable symTab, Type thisFunctionType] returns [Code3a code] : ^( BODY st= statement[symTab, thisFunctionType] ) ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131203.html#refoperation148739"><b>checkAndDeclArray</b></a></td><td><a href="class131203.html#refclass131203"><b>TypeCheck</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131203.html#refoperation148355"><b>checkAndDeclIdent</b></a></td><td><a href="class131203.html#refclass131203"><b>TypeCheck</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131203.html#refoperation148483"><b>checkAndDeclParmIdent</b></a></td><td><a href="class131203.html#refclass131203"><b>TypeCheck</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131203.html#refoperation148611"><b>checkAndDeclParmPointer</b></a></td><td><a href="class131203.html#refclass131203"><b>TypeCheck</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131203.html#refoperation148995"><b>checkArrayElem</b></a></td><td><a href="class131203.html#refclass131203"><b>TypeCheck</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131203.html#refoperation149123"><b>checkAssign</b></a></td><td><a href="class131203.html#refclass131203"><b>TypeCheck</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131203.html#refoperation147587"><b>checkBinOp</b></a></td><td><a href="class131203.html#refclass131203"><b>TypeCheck</b></a></td><td> an Example<br /><br />Type checking for a binary operation - in VSL+: integer operations only!</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131203.html#refoperation149251"><b>checkFuncCall</b></a></td><td><a href="class131203.html#refclass131203"><b>TypeCheck</b></a></td><td>Verifies the call is correct (valid function name and compatible argument<br />types). Returns Type.INT if no error occurs, Type.ERROR otherwise.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131203.html#refoperation148099"><b>checkFuncDecl</b></a></td><td><a href="class131203.html#refclass131203"><b>TypeCheck</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131203.html#refoperation148867"><b>checkIdent</b></a></td><td><a href="class131203.html#refclass131203"><b>TypeCheck</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131203.html#refoperation147971"><b>checkProtoDecl</b></a></td><td><a href="class131203.html#refclass131203"><b>TypeCheck</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130691.html#refoperation145539"><b>clear</b></a></td><td><a href="class130691.html#refclass130691"><b>MIPSRegDesc</b></a></td><td>if cleared, the register is no more associated with a variable</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation142467"><b>clearAll</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td>clear all descriptors</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation142339"><b>clearDescriptor</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td>clear a descriptor</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128515.html#refoperation130563"><b>Code3a</b></a></td><td><a href="class128515.html#refclass128515"><b>Code3a</b></a></td><td>Creates an empty list of TAC</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128515.html#refoperation130691"><b>Code3a</b></a></td><td><a href="class128515.html#refclass128515"><b>Code3a</b></a></td><td>Creates a list of TAC with only one statement.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129539.html#refoperation135299"><b>ConstSymbol</b></a></td><td><a href="class129539.html#refclass129539"><b>ConstSymbol</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128771.html#refoperation135555"><b>Data3a</b></a></td><td><a href="class128771.html#refclass128771"><b>Data3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation163075"><b>decl_item</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "decl_item"<br /> ./src/VSLParser.g:124:1: decl_item : ( IDENT | IDENT LB INTEGER RB -&gt; ^( ARDECL IDENT INTEGER ) );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation162819"><b>decl_list</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "decl_list"<br /> ./src/VSLParser.g:120:1: decl_list : decl_item ( COM ! decl_item )* ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation162563"><b>declaration</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "declaration"<br /> ./src/VSLParser.g:116:1: declaration : ( INT_KW decl_list )+ -&gt; ^( DECL ( decl_list )+ ) ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation166403"><b>declaration</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "read_item"<br /> $ANTLR start "declaration"<br /> ./src/VSLTreeParser.g:347:1: declaration[SymbolTable symTab] returns [Code3a code] : ( ^( DECL (i= item_declaration[symTab] )* ) |);</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129411.html#refoperation146819"><b>enterScope</b></a></td><td><a href="class129411.html#refclass129411"><b>SymbolTable</b></a></td><td>Pushes a new table, which becomes the current one. Updates the current<br />scope accordingly.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128259.html#refoperation128643"><b>equals</b></a></td><td><a href="class128259.html#refclass128259"><b>Type</b></a></td><td>Returns true iff the given parameter is an object with the same type as<br />this one.<br /><br />@param o<br />           object to be compared with.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129155.html#refoperation136835"><b>ExpAttribute</b></a></td><td><a href="class129155.html#refclass129155"><b>ExpAttribute</b></a></td><td>Constructor of ExpAttribute<br /><br />@param ty<br />           Type: the type associated with the expression<br />@param cod<br />           Code3a: the code implementing the expression<br />@param pl<br />           Operand3a: a representation of memory place for expression<br />           value</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation160515"><b>expression</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "expression"<br /> ./src/VSLParser.g:78:1: expression : factor ( ( PLUS ^| MINUS ^) factor )* ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation165507"><b>expression</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "instruction_list"<br /> $ANTLR start "expression"<br /> ./src/VSLTreeParser.g:225:1: expression[SymbolTable symTab] returns [ExpAttribute expAtt] : ( ^( PLUS e1= expression[symTab] e2= expression[symTab] ) | ^( MINUS e1= expression[symTab] e2= expression[symTab] ) | ^( MUL e1= expression[symTab] e2= expression[symTab] ) | ^( DIV e1= expression[symTab] e2= expression[symTab] ) |pe= primary_exp[symTab] );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129923.html#refoperation137859"><b>extend</b></a></td><td><a href="class129923.html#refclass129923"><b>FunctionType</b></a></td><td>Extend the arity of this function type, from f(t1, ..., tn) to f(t1, ...,<br />tn, t).<br /><br />Use this when iteratively constructing the entire type of a function<br />call.<br /><br />@param t<br />           the new argument type to be added.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation160771"><b>factor</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "factor"<br /> ./src/VSLParser.g:82:1: factor : primary ( ( MUL ^| DIV ^) primary )* ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation142211"><b>flushAll</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td>flushAll: spill all registers and clear their descriptors</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation158211"><b>function</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "function"<br /> ./src/VSLParser.g:30:1: function : FUNC_KW type IDENT LP param_list RP statement -&gt; ^( FUNC_KW type IDENT param_list ^( BODY statement ) ) ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation164227"><b>function</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "program_unit"<br /> $ANTLR start "function"<br /> ./src/VSLTreeParser.g:32:1: function[SymbolTable symTab] returns [Code3a code] : ^( FUNC_KW rt= type IDENT pl= param_list[symTab, ft] b= body[symTab, ft] ) ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129283.html#refoperation136963"><b>FunctionSymbol</b></a></td><td><a href="class129283.html#refclass129283"><b>FunctionSymbol</b></a></td><td>Constructor<br /><br />@param lab<br />           LabelAttribute: the label associated<br />@param t<br />           : a function type handled separately in compilation process</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129923.html#refoperation137347"><b>FunctionType</b></a></td><td><a href="class129923.html#refclass129923"><b>FunctionType</b></a></td><td>Creates a new function type with the given return type and whether it is<br />a prototype declaration or a function definition.<br /><br />@param returnType<br />           Return type of the function<br />@param prototype<br />           True iff this is a prototype declaration (instead of a<br />           function definition)</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129923.html#refoperation137475"><b>FunctionType</b></a></td><td><a href="class129923.html#refclass129923"><b>FunctionType</b></a></td><td>Creates a new function type indifferent of prototype/function status<br />(used to check function calls).<br /><br />@param returnType<br />           Return type of the function</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128899.html#refoperation132483"><b>genArg</b></a></td><td><a href="class128899.html#refclass128899"><b>Code3aGenerator</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128899.html#refoperation132227"><b>genBeginFunc</b></a></td><td><a href="class128899.html#refclass128899"><b>Code3aGenerator</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128899.html#refoperation132099"><b>genBinOp</b></a></td><td><a href="class128899.html#refclass128899"><b>Code3aGenerator</b></a></td><td>Generate code for a binary operation<br /><br />@param op<br />           must be a code op: Inst3a.TAC.XXX</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130435.html#refoperation140547"><b>genCode</b></a></td><td><a href="class130435.html#refclass130435"><b>MIPSCodeGenerator</b></a></td><td> ////////////////////////////////////////////////////////////<br /><br />This method generates code for a whole three address code fragment. The<br />resulting assembly code is emitted on the data output stream.<br /><br />@param c<br />           : Code 3a to be translated</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128899.html#refoperation133507"><b>genFuncCall</b></a></td><td><a href="class128899.html#refclass128899"><b>Code3aGenerator</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128899.html#refoperation133251"><b>genIfThenElse</b></a></td><td><a href="class128899.html#refclass128899"><b>Code3aGenerator</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128899.html#refoperation132739"><b>genPrintInt</b></a></td><td><a href="class128899.html#refclass128899"><b>Code3aGenerator</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128899.html#refoperation132611"><b>genPrintS</b></a></td><td><a href="class128899.html#refclass128899"><b>Code3aGenerator</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128899.html#refoperation132355"><b>genRead</b></a></td><td><a href="class128899.html#refclass128899"><b>Code3aGenerator</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128899.html#refoperation131971"><b>genVar</b></a></td><td><a href="class128899.html#refclass128899"><b>Code3aGenerator</b></a></td><td>Generates the 3a statement: VAR t</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128899.html#refoperation133379"><b>genWhile</b></a></td><td><a href="class128899.html#refclass128899"><b>Code3aGenerator</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130307.html#refoperation139907"><b>get1</b></a></td><td><a href="class130307.html#refclass130307"><b>MIPSCGTriplet</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130307.html#refoperation140035"><b>get2</b></a></td><td><a href="class130307.html#refclass130307"><b>MIPSCGTriplet</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130307.html#refoperation140163"><b>get3</b></a></td><td><a href="class130307.html#refclass130307"><b>MIPSCGTriplet</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128643.html#refoperation138499"><b>getA</b></a></td><td><a href="class128643.html#refclass128643"><b>Inst3a</b></a></td><td>Self explained<br /><br />@return Operand3a</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation143363"><b>getAnother</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td>getAnother get a register to hold the second operand of a computation</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129923.html#refoperation137731"><b>getArguments</b></a></td><td><a href="class129923.html#refclass129923"><b>FunctionType</b></a></td><td>Returns the list of argument types of this function (without the return<br />type).<br /><br />@return the list of argument types of this function.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128643.html#refoperation138627"><b>getB</b></a></td><td><a href="class128643.html#refclass128643"><b>Inst3a</b></a></td><td>Self explained<br /><br />@return Operand3a</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128643.html#refoperation138755"><b>getC</b></a></td><td><a href="class128643.html#refclass128643"><b>Inst3a</b></a></td><td>Self explained<br /><br />@return Operand3a</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128515.html#refoperation131203"><b>getCode</b></a></td><td><a href="class128515.html#refclass128515"><b>Code3a</b></a></td><td>To be used by the (machine) code generator<br /><br />@return List&lt;Inst3a&gt; the 3a code</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation151299"><b>getDelegates</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> delegates<br /> delegators</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation156419"><b>getDelegates</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> delegates</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation163203"><b>getDelegates</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> delegates</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation143875"><b>getEmptyRegister</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td> get an empty register different from r1 and r2 if it exists</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation143747"><b>getEmptyRegister</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td> get an empty register different from r1 if it exists</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation143619"><b>getEmptyRegister</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation143235"><b>getErasable</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td>getErasable gets a register that will hold an operand and be overwritten<br />by the result.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation151811"><b>getGrammarFileName</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation157187"><b>getGrammarFileName</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation163715"><b>getGrammarFileName</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128771.html#refoperation135683"><b>getLabel</b></a></td><td><a href="class128771.html#refclass128771"><b>Data3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128131.html#refoperation129027"><b>getLength</b></a></td><td><a href="class128131.html#refclass128131"><b>ArrayType</b></a></td><td>Returns the dimension of this array (used only for code generation).</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130691.html#refoperation145155"><b>getMemory</b></a></td><td><a href="class130691.html#refclass130691"><b>MIPSRegDesc</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130691.html#refoperation145283"><b>getModif</b></a></td><td><a href="class130691.html#refclass130691"><b>MIPSRegDesc</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128387.html#refoperation130179"><b>getName3a</b></a></td><td><a href="class128387.html#refclass128387"><b>CGInterface</b></a></td><td>This method must return a printable view of a TAC operand. Variable name<br />for a variable, integer string for an integer. Recall that the TAC name<br />of a function is the associated label!!<br /><br />@return String</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129539.html#refoperation135427"><b>getName3a</b></a></td><td><a href="class129539.html#refclass129539"><b>ConstSymbol</b></a></td><td>For code 3a printing</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129283.html#refoperation137219"><b>getName3a</b></a></td><td><a href="class129283.html#refclass129283"><b>FunctionSymbol</b></a></td><td>Necessary for TAC printing</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129667.html#refoperation139523"><b>getName3a</b></a></td><td><a href="class129667.html#refclass129667"><b>LabelSymbol</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129027.html#refoperation134147"><b>getName3a</b></a></td><td><a href="class129027.html#refclass129027"><b>Operand3a</b></a></td><td> Must be overridden by subclasses</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130947.html#refoperation150659"><b>getName3a</b></a></td><td><a href="class130947.html#refclass130947"><b>VarSymbol</b></a></td><td>for code 3a printing</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation144259"><b>getNotModifiedRegister</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td> get a not modified register different from r1 and r2 if it exists</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation144131"><b>getNotModifiedRegister</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td> get a not modified register different from r1 if it exists</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation144003"><b>getNotModifiedRegister</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129027.html#refoperation133763"><b>getOffset</b></a></td><td><a href="class129027.html#refclass129027"><b>Operand3a</b></a></td><td>returns the address of the operand.<br /><br />@return the address</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128643.html#refoperation138371"><b>getOp</b></a></td><td><a href="class128643.html#refclass128643"><b>Inst3a</b></a></td><td>Returns the operation code<br /><br />@return int</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130691.html#refoperation145411"><b>getRegNumber</b></a></td><td><a href="class130691.html#refclass130691"><b>MIPSRegDesc</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129923.html#refoperation137603"><b>getReturnType</b></a></td><td><a href="class129923.html#refclass129923"><b>FunctionType</b></a></td><td>Returns the return type of this function (it can be VOID).<br /><br />@return the return type of this function (it can be VOID).</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128387.html#refoperation130307"><b>getScope</b></a></td><td><a href="class128387.html#refclass128387"><b>CGInterface</b></a></td><td>Returns the scope of a TAC operand if not meaningless. Othewise, should<br />return -1.<br /><br />@return integer</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129283.html#refoperation137091"><b>getScope</b></a></td><td><a href="class129283.html#refclass129283"><b>FunctionSymbol</b></a></td><td>The scope of a function is always zero in VSL+</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129027.html#refoperation134275"><b>getScope</b></a></td><td><a href="class129027.html#refclass129027"><b>Operand3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129411.html#refoperation147331"><b>getScope</b></a></td><td><a href="class129411.html#refclass129411"><b>SymbolTable</b></a></td><td>Returns the current scope.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130947.html#refoperation150787"><b>getScope</b></a></td><td><a href="class130947.html#refclass130947"><b>VarSymbol</b></a></td><td>Self explained</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128387.html#refoperation130435"><b>getSize</b></a></td><td><a href="class128387.html#refclass128387"><b>CGInterface</b></a></td><td>Returns the size (in bytes) of a TAC operand unless meaningless. -1 if<br />not appropriate.<br /><br />@return the size</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129027.html#refoperation134403"><b>getSize</b></a></td><td><a href="class129027.html#refclass129027"><b>Operand3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128259.html#refoperation128259"><b>getSize</b></a></td><td><a href="class128259.html#refclass128259"><b>Type</b></a></td><td>Returns the size in bytes.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation143491"><b>getSome</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td>get some register: get a register without associating it with some place<br />in memory. We use the same policy as above to select it</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128771.html#refoperation135811"><b>getText</b></a></td><td><a href="class128771.html#refclass128771"><b>Data3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation157059"><b>getTokenNames</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation163587"><b>getTokenNames</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134147.html#refoperation161155"><b>getTree</b></a></td><td><a href="class134147.html#refclass134147"><b>argument_list_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133507.html#refoperation159875"><b>getTree</b></a></td><td><a href="class133507.html#refclass133507"><b>array_elem_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133379.html#refoperation159619"><b>getTree</b></a></td><td><a href="class133379.html#refclass133379"><b>block_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135043.html#refoperation162947"><b>getTree</b></a></td><td><a href="class135043.html#refclass135043"><b>decl_item_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134915.html#refoperation162691"><b>getTree</b></a></td><td><a href="class134915.html#refclass134915"><b>decl_list_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134787.html#refoperation162435"><b>getTree</b></a></td><td><a href="class134787.html#refclass134787"><b>declaration_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133763.html#refoperation160387"><b>getTree</b></a></td><td><a href="class133763.html#refclass133763"><b>expression_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133891.html#refoperation160643"><b>getTree</b></a></td><td><a href="class133891.html#refclass133891"><b>factor_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132611.html#refoperation158083"><b>getTree</b></a></td><td><a href="class132611.html#refclass132611"><b>function_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133635.html#refoperation160131"><b>getTree</b></a></td><td><a href="class133635.html#refclass133635"><b>inst_list_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132995.html#refoperation158851"><b>getTree</b></a></td><td><a href="class132995.html#refclass132995"><b>param_list_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133123.html#refoperation159107"><b>getTree</b></a></td><td><a href="class133123.html#refclass133123"><b>param_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134019.html#refoperation160899"><b>getTree</b></a></td><td><a href="class134019.html#refclass134019"><b>primary_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134403.html#refoperation161667"><b>getTree</b></a></td><td><a href="class134403.html#refclass134403"><b>print_item_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134275.html#refoperation161411"><b>getTree</b></a></td><td><a href="class134275.html#refclass134275"><b>print_list_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132355.html#refoperation157571"><b>getTree</b></a></td><td><a href="class132355.html#refclass132355"><b>program_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132739.html#refoperation158339"><b>getTree</b></a></td><td><a href="class132739.html#refclass132739"><b>proto_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134659.html#refoperation162179"><b>getTree</b></a></td><td><a href="class134659.html#refclass134659"><b>read_item_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134531.html#refoperation161923"><b>getTree</b></a></td><td><a href="class134531.html#refclass134531"><b>read_list_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132099.html#refoperation157315"><b>getTree</b></a></td><td><a href="class132099.html#refclass132099"><b>s_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133251.html#refoperation159363"><b>getTree</b></a></td><td><a href="class133251.html#refclass133251"><b>statement_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132867.html#refoperation158595"><b>getTree</b></a></td><td><a href="class132867.html#refclass132867"><b>type_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132483.html#refoperation157827"><b>getTree</b></a></td><td><a href="class132483.html#refclass132483"><b>unit_return</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation156931"><b>getTreeAdaptor</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128259.html#refoperation128771"><b>hashCode</b></a></td><td><a href="class128259.html#refclass128259"><b>Type</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129795.html#refoperation136579"><b>incompatibleTypes</b></a></td><td><a href="class129795.html#refclass129795"><b>Errors</b></a></td><td>Error message for incompatible types (i.e., assignment of INT value to<br />POINTER variable). Note that this uses a very broad definition of type<br />incompatibility, i.e., several kinds of invalid operations can be mapped<br />to a type incompatibility issue.<br /><br />@param token<br />           ANTLR token (for line/column numbering).<br />@param expectedType<br />           expected type (e.g., INT for a return value). Uses the<br />           toString() method of the object.<br />@param actualType<br />           actual obtained type (which is incompatible with the previous<br />           one). Uses the toString() method of the object.<br />@param extra<br />           additional information to the error message, or null if none.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131075.html#refoperation146435"><b>insert</b></a></td><td><a href="class131075.html#refclass131075"><b>SingleScopeTable</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129411.html#refoperation147203"><b>insert</b></a></td><td><a href="class129411.html#refclass129411"><b>SymbolTable</b></a></td><td>Puts a pair (key, value) in the current table.<br /><br />@param name<br />           : name (String)<br />@param t<br />           : value of Operand3a type</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128643.html#refoperation138243"><b>Inst3a</b></a></td><td><a href="class128643.html#refclass128643"><b>Inst3a</b></a></td><td>Constructor<br /><br />@param op<br />           : TAC operator<br />@param a<br />           : Operand3a<br />@param b<br />           : Operand3a or null<br />@param c<br />           : Operand3a or null</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation160259"><b>inst_list</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "inst_list"<br /> ./src/VSLParser.g:74:1: inst_list : ( statement )+ -&gt; ^( INST ( statement )+ ) ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation165379"><b>instruction_list</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "array_elem"<br /> $ANTLR start "instruction_list"<br /> ./src/VSLTreeParser.g:220:1: instruction_list[SymbolTable symTab, Type thisFunctionType] returns [Code3a code] : ^( INST (st= statement[symTab, thisFunctionType] )+ ) ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128387.html#refoperation129795"><b>isArray</b></a></td><td><a href="class128387.html#refclass128387"><b>CGInterface</b></a></td><td>Test if a TAC operand is an array<br /><br />@return a boolean</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129027.html#refoperation134531"><b>isArray</b></a></td><td><a href="class129027.html#refclass129027"><b>Operand3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128131.html#refoperation129155"><b>isCompatible</b></a></td><td><a href="class128131.html#refclass128131"><b>ArrayType</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129923.html#refoperation137987"><b>isCompatible</b></a></td><td><a href="class129923.html#refclass129923"><b>FunctionType</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128259.html#refoperation128387"><b>isCompatible</b></a></td><td><a href="class128259.html#refclass128259"><b>Type</b></a></td><td>Tests if two types are compatible. For simple types, compatibility is<br />equality of types. Sub-types (e.g. function types) must override this<br />function accordingly.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128387.html#refoperation129411"><b>isConstInteger</b></a></td><td><a href="class128387.html#refclass128387"><b>CGInterface</b></a></td><td>Test if a TAC operand is an integer literal<br /><br />@return a boolean</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129027.html#refoperation134659"><b>isConstInteger</b></a></td><td><a href="class129027.html#refclass129027"><b>Operand3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128515.html#refoperation131331"><b>isEmpty</b></a></td><td><a href="class128515.html#refclass128515"><b>Code3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation144387"><b>isInRegister</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128387.html#refoperation130051"><b>isLabel</b></a></td><td><a href="class128387.html#refclass128387"><b>CGInterface</b></a></td><td>Test if a TAC operand is a label<br /><br />@return a boolean</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129027.html#refoperation134787"><b>isLabel</b></a></td><td><a href="class129027.html#refclass129027"><b>Operand3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128387.html#refoperation129667"><b>isParam</b></a></td><td><a href="class128387.html#refclass128387"><b>CGInterface</b></a></td><td>Test if a TAC_VAR is a parameter of a function<br /><br />@return a boolean</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129027.html#refoperation135171"><b>isParam</b></a></td><td><a href="class129027.html#refclass129027"><b>Operand3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130947.html#refoperation151043"><b>isParam</b></a></td><td><a href="class130947.html#refclass130947"><b>VarSymbol</b></a></td><td>MIPS code generator interface only</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128387.html#refoperation129923"><b>isPointer</b></a></td><td><a href="class128387.html#refclass128387"><b>CGInterface</b></a></td><td>Test if a TAC operand is a pointer. When an array is passed as a<br />parameter, the value of the the address is passed to the subroutine. So<br />it is a pointer.<br /><br />@return a boolean</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129027.html#refoperation134915"><b>isPointer</b></a></td><td><a href="class129027.html#refclass129027"><b>Operand3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128387.html#refoperation129539"><b>isVarInteger</b></a></td><td><a href="class128387.html#refclass128387"><b>CGInterface</b></a></td><td>Test if a TAC operand is an integer variable<br /><br />@return a boolean</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129027.html#refoperation135043"><b>isVarInteger</b></a></td><td><a href="class129027.html#refclass129027"><b>Operand3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation166531"><b>item_declaration</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "declaration"<br /> $ANTLR start "item_declaration"<br /> ./src/VSLTreeParser.g:353:1: item_declaration[SymbolTable symTab] returns [Code3a code] : ( IDENT |ad= array_declaration[symTab] );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129667.html#refoperation139395"><b>LabelSymbol</b></a></td><td><a href="class129667.html#refclass129667"><b>LabelSymbol</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129411.html#refoperation146947"><b>leaveScope</b></a></td><td><a href="class129411.html#refclass129411"><b>SymbolTable</b></a></td><td>Pops the current table and decrements the current scope.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation142723"><b>loadRegisterMIPS</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td>load a value in a register. The register descriptor is updated<br />accordingly</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation142851"><b>loadRegisterMIPS</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131075.html#refoperation146307"><b>lookup</b></a></td><td><a href="class131075.html#refclass131075"><b>SingleScopeTable</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129411.html#refoperation147075"><b>lookup</b></a></td><td><a href="class129411.html#refclass129411"><b>SymbolTable</b></a></td><td>Lookup for a value associated with a key. Returns null if the key is not<br />found.<br /><br />@param name<br />           string - the key<br />@return Value with Operand3a type (which might be necessary to cast)</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131459.html#refoperation151171"><b>main</b></a></td><td><a href="class131459.html#refclass131459"><b>VslComp</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation152451"><b>mASCII</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "DIGIT"<br /> $ANTLR start "ASCII"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation153987"><b>mASSIGN_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "VOID_KW"<br /> $ANTLR start "ASSIGN_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation153347"><b>mCOM</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "RC"<br /> $ANTLR start "COM"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation152067"><b>mCOMMENT</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "WS"<br /> $ANTLR start "COMMENT"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation152323"><b>mDIGIT</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "LETTER"<br /> $ANTLR start "DIGIT"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation155779"><b>mDIV</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "MUL"<br /> $ANTLR start "DIV"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation155139"><b>mDO_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "WHILE_KW"<br /> $ANTLR start "DO_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation154755"><b>mELSE_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "THEN_KW"<br /> $ANTLR start "ELSE_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation154883"><b>mFI_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "ELSE_KW"<br /> $ANTLR start "FI_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation153475"><b>mFUNC_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "COM"<br /> $ANTLR start "FUNC_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation155907"><b>mIDENT</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "DIV"<br /> $ANTLR start "IDENT"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation154499"><b>mIF_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "READ_KW"<br /> $ANTLR start "IF_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation153731"><b>mINT_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "PROTO_KW"<br /> $ANTLR start "INT_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation156163"><b>mINTEGER</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "TEXT"<br /> $ANTLR start "INTEGER"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130307.html#refoperation139779"><b>MIPSCGTriplet</b></a></td><td><a href="class130307.html#refclass130307"><b>MIPSCGTriplet</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130435.html#refoperation140291"><b>MIPSCodeGenerator</b></a></td><td><a href="class130435.html#refclass130435"><b>MIPSCodeGenerator</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation141955"><b>MIPSRegAlloc</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130691.html#refoperation145027"><b>MIPSRegDesc</b></a></td><td><a href="class130691.html#refclass130691"><b>MIPSRegDesc</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129795.html#refoperation136707"><b>miscError</b></a></td><td><a href="class129795.html#refclass129795"><b>Errors</b></a></td><td>Miscellaneous error message (for errors which do not fit any other<br />method). Note: all "standard" errors should fit in one of the previous<br />categories.<br /><br />@param token<br />           ANTLR token (for line/column numbering).<br />@param msg<br />           the entire error message describing the error.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation152835"><b>mLB</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "RP"<br /> $ANTLR start "LB"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation153091"><b>mLC</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "RB"<br /> $ANTLR start "LC"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation152195"><b>mLETTER</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "COMMENT"<br /> $ANTLR start "LETTER"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation152579"><b>mLP</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "ASCII"<br /> $ANTLR start "LP"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation155523"><b>mMINUS</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "PLUS"<br /> $ANTLR start "MINUS"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation155651"><b>mMUL</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "MINUS"<br /> $ANTLR start "MUL"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation155267"><b>mOD_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "DO_KW"<br /> $ANTLR start "OD_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation155395"><b>mPLUS</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "OD_KW"<br /> $ANTLR start "PLUS"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation154243"><b>mPRINT_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "RETURN_KW"<br /> $ANTLR start "PRINT_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation153603"><b>mPROTO_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "FUNC_KW"<br /> $ANTLR start "PROTO_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation152963"><b>mRB</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "LB"<br /> $ANTLR start "RB"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation153219"><b>mRC</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "LC"<br /> $ANTLR start "RC"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation154371"><b>mREAD_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "PRINT_KW"<br /> $ANTLR start "READ_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation154115"><b>mRETURN_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "ASSIGN_KW"<br /> $ANTLR start "RETURN_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation152707"><b>mRP</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "LP"<br /> $ANTLR start "RP"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation156035"><b>mTEXT</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "IDENT"<br /> $ANTLR start "TEXT"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation154627"><b>mTHEN_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "IF_KW"<br /> $ANTLR start "THEN_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation156291"><b>mTokens</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "INTEGER"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation153859"><b>mVOID_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "INT_KW"<br /> $ANTLR start "VOID_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation155011"><b>mWHILE_KW</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR end "FI_KW"<br /> $ANTLR start "WHILE_KW"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation151939"><b>mWS</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td> $ANTLR start "WS"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130819.html#refoperation146051"><b>newLabel</b></a></td><td><a href="class130819.html#refclass130819"><b>SymbDistrib</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130819.html#refoperation145923"><b>newTemp</b></a></td><td><a href="class130819.html#refclass130819"><b>SymbDistrib</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129027.html#refoperation133891"><b>Operand3a</b></a></td><td><a href="class129027.html#refclass129027"><b>Operand3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation159235"><b>param</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "param"<br /> ./src/VSLParser.g:48:1: param : ( IDENT | IDENT LB RB -&gt; ^( ARRAY IDENT ) );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation164739"><b>param</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "param_list"<br /> $ANTLR start "param"<br /> ./src/VSLTreeParser.g:82:1: param[SymbolTable symTab, FunctionType ft] returns [Code3a code] : ( IDENT | ^( ARRAY IDENT ) );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation158979"><b>param_list</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "param_list"<br /> ./src/VSLParser.g:43:1: param_list : ( param ( COM param )* -&gt; ^( PARAM ( param )* ) | -&gt; ^( PARAM ) );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation164611"><b>param_list</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "type"<br /> $ANTLR start "param_list"<br /> ./src/VSLTreeParser.g:76:1: param_list[SymbolTable symTab, FunctionType ft] returns [Code3a code] : ( ^( PARAM (p= param[symTab, ft] )* ) |);</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation161027"><b>primary</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "primary"<br /> ./src/VSLParser.g:86:1: primary : ( INTEGER | IDENT | array_elem | IDENT LP ( argument_list )? RP -&gt; ^( FCALL IDENT ( argument_list )? ) | LP ! expression RP !);</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation165635"><b>primary_exp</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "expression"<br /> $ANTLR start "primary_exp"<br /> ./src/VSLTreeParser.g:238:1: primary_exp[SymbolTable symTab] returns [ExpAttribute expAtt] : ( INTEGER | IDENT |ae= array_elem[symTab, null] | ^( FCALL IDENT al= argument_list[symTab, ft] ) );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128515.html#refoperation131459"><b>print</b></a></td><td><a href="class128515.html#refclass128515"><b>Code3a</b></a></td><td>Print the 3A code.<br /></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128771.html#refoperation136067"><b>print</b></a></td><td><a href="class128771.html#refclass128771"><b>Data3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128643.html#refoperation139139"><b>print</b></a></td><td><a href="class128643.html#refclass128643"><b>Inst3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131075.html#refoperation146563"><b>print</b></a></td><td><a href="class131075.html#refclass131075"><b>SingleScopeTable</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129411.html#refoperation147459"><b>print</b></a></td><td><a href="class129411.html#refclass129411"><b>SymbolTable</b></a></td><td>For debugging; displays the name of the key associated with whatever the<br />user wants to display by mean of a &lt;b&gt;toString&lt;/b&gt; method on the object<br />associated with the key.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128515.html#refoperation131587"><b>print_in_file</b></a></td><td><a href="class128515.html#refclass128515"><b>Code3a</b></a></td><td>Print the 3A code in a file</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128643.html#refoperation139267"><b>print_in_file</b></a></td><td><a href="class128643.html#refclass128643"><b>Inst3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation161795"><b>print_item</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "print_item"<br /> ./src/VSLParser.g:102:1: print_item : ( TEXT | expression );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation166019"><b>print_item</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "print_list"<br /> $ANTLR start "print_item"<br /> ./src/VSLTreeParser.g:292:1: print_item[SymbolTable symTab] returns [Code3a code] : ( TEXT |exp= expression[symTab] );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation161539"><b>print_list</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "print_list"<br /> ./src/VSLParser.g:98:1: print_list : print_item ( COM ! print_item )* ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation165891"><b>print_list</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "argument_list"<br /> $ANTLR start "print_list"<br /> ./src/VSLTreeParser.g:287:1: print_list[SymbolTable symTab] returns [Code3a code] : (pi= print_item[symTab] )* ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131331.html#refoperation149635"><b>printError</b></a></td><td><a href="class131331.html#refclass131331"><b>Util</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131331.html#refoperation149763"><b>printError</b></a></td><td><a href="class131331.html#refclass131331"><b>Util</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131331.html#refoperation149891"><b>printError</b></a></td><td><a href="class131331.html#refclass131331"><b>Util</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131331.html#refoperation150147"><b>printWarning</b></a></td><td><a href="class131331.html#refclass131331"><b>Util</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131331.html#refoperation150275"><b>printWarning</b></a></td><td><a href="class131331.html#refclass131331"><b>Util</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131331.html#refoperation150019"><b>printWarning</b></a></td><td><a href="class131331.html#refclass131331"><b>Util</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation157699"><b>program</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "program"<br /> ./src/VSLParser.g:21:1: program : ( unit )+ -&gt; ^( PROG ( unit )+ ) ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation163971"><b>program</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR start "program"<br /> ./src/VSLTreeParser.g:19:1: program returns [Code3a code, int status] : ^( PROG (pu= program_unit[symTab] )+ ) ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation164099"><b>program_unit</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "program"<br /> $ANTLR start "program_unit"<br /> ./src/VSLTreeParser.g:27:1: program_unit[SymbolTable symTab] returns [Code3a code] : (f= function[symTab] |p= proto[symTab] );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation158467"><b>proto</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "proto"<br /> ./src/VSLParser.g:34:1: proto : PROTO_KW ^ type IDENT LP ! param_list RP !;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation164355"><b>proto</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "function"<br /> $ANTLR start "proto"<br /> ./src/VSLTreeParser.g:56:1: proto[SymbolTable symTab] : ^( PROTO_KW rt= type IDENT pl= param_list[symTab, ft] ) ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation162307"><b>read_item</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "read_item"<br /> ./src/VSLParser.g:111:1: read_item : ( IDENT | array_elem );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation166275"><b>read_item</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "read_list"<br /> $ANTLR start "read_item"<br /> ./src/VSLTreeParser.g:315:1: read_item[SymbolTable symTab] returns [Code3a code] : ( IDENT |ae= array_elem[symTab, tmpExp] );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation162051"><b>read_list</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "read_list"<br /> ./src/VSLParser.g:107:1: read_list : read_item ( COM ! read_item )* ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation166147"><b>read_list</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "print_item"<br /> $ANTLR start "read_list"<br /> ./src/VSLTreeParser.g:307:1: read_list[SymbolTable symTab] returns [Code3a code] : (ri= read_item[symTab] )* ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129795.html#refoperation136451"><b>redefinedIdentifier</b></a></td><td><a href="class129795.html#refclass129795"><b>Errors</b></a></td><td>Error message for a redefined identifier (e.g., two local variable<br />declarations with same name).<br /><br />@param token<br />           ANTLR token (for line/column numbering).<br />@param name<br />           name of the redefined identifier.<br />@param extra<br />           additional information to the error message, or null if none.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131203.html#refoperation147715"><b>reserveFunctionName</b></a></td><td><a href="class131203.html#refclass131203"><b>TypeCheck</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation157443"><b>s</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "s"<br /> ./src/VSLParser.g:17:1: s : program ;</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation143107"><b>search</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td>search for a symbol in a register, return -1 if not found</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130691.html#refoperation145795"><b>set</b></a></td><td><a href="class130691.html#refclass130691"><b>MIPSRegDesc</b></a></td><td>set the attributes</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation142979"><b>setDescriptor</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td>insert a descriptor entry for the given name</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129027.html#refoperation133635"><b>setOffset</b></a></td><td><a href="class129027.html#refclass129027"><b>Operand3a</b></a></td><td>set the address of the operand<br /><br />@param off<br />           int</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130947.html#refoperation150915"><b>setParam</b></a></td><td><a href="class130947.html#refclass130947"><b>VarSymbol</b></a></td><td>Put param attribute to true</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation156803"><b>setTreeAdaptor</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131075.html#refoperation146179"><b>SingleScopeTable</b></a></td><td><a href="class131075.html#refclass131075"><b>SingleScopeTable</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130691.html#refoperation145667"><b>spill</b></a></td><td><a href="class130691.html#refclass130691"><b>MIPSRegDesc</b></a></td><td>dump the register content in the associated memory, if different</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation142083"><b>spillAll</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td>spilling of all registers. Values are dumped in memory if necessary</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130563.html#refoperation142595"><b>spillOne</b></a></td><td><a href="class130563.html#refclass130563"><b>MIPSRegAlloc</b></a></td><td>spill a register</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation159491"><b>statement</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "statement"<br /> ./src/VSLParser.g:53:1: statement : ( IDENT ASSIGN_KW expression -&gt; ^( ASSIGN_KW expression IDENT ) | array_elem ASSIGN_KW expression -&gt; ^( ASSIGN_KW expression array_elem ) | RETURN_KW ^ expression | PRINT_KW ^ print_list | READ_KW ^ read_list | IF_KW ^ expression THEN_KW ! statement ( ELSE_KW ! statement )? FI_KW !| WHILE_KW ^ expression DO_KW ! statement OD_KW !| IDENT LP ( argument_list )? RP -&gt; ^( FCALL_S IDENT ( argument_list )? ) | block );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation164995"><b>statement</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "body"<br /> $ANTLR start "statement"<br /> ./src/VSLTreeParser.g:102:1: statement[SymbolTable symTab, Type thisFunctionType] returns [Code3a code] : ( ^( ASSIGN_KW e= expression[symTab] a= assign_lhs[symTab, e] ) | ^( RETURN_KW e= expression[symTab] ) | ^( PRINT_KW pl= print_list[symTab] ) | ^( READ_KW rl= read_list[symTab] ) | ^( IF_KW e= expression[symTab] s1= statement[symTab, thisFunctionType] (s2= statement[symTab, thisFunctionType] )? ) | ^( WHILE_KW e= expression[symTab] s= statement[symTab, thisFunctionType] ) | ^( BLOCK d= declaration[symTab] il= instruction_list[symTab, thisFunctionType] ) | ^( FCALL_S IDENT al= argument_list[symTab, fType] ) );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129411.html#refoperation146691"><b>SymbolTable</b></a></td><td><a href="class129411.html#refclass129411"><b>SymbolTable</b></a></td><td>Creates a new symbol table. The current scope is zero.<br /></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128131.html#refoperation129283"><b>toString</b></a></td><td><a href="class128131.html#refclass128131"><b>ArrayType</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128515.html#refoperation131715"><b>toString</b></a></td><td><a href="class128515.html#refclass128515"><b>Code3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128771.html#refoperation135939"><b>toString</b></a></td><td><a href="class128771.html#refclass128771"><b>Data3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129923.html#refoperation138115"><b>toString</b></a></td><td><a href="class129923.html#refclass129923"><b>FunctionType</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128643.html#refoperation139011"><b>toString</b></a></td><td><a href="class128643.html#refclass128643"><b>Inst3a</b></a></td><td>Prints a TAC instruction. This method is put here for debug purpose only.<br />TAC with type information is just an intermediate representation of the<br />program. The printed form lack some information to be completely<br />equivalent to the source program. &lt;br&gt;<br />The toString method is robustified for debug purposes. If an operand is<br />missing (null) a "####" is returned in place of the name. Otherwise, the<br />name, as defined by the method &lt;b&gt;getName3a&lt;/b&gt;, is returned.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129667.html#refoperation139651"><b>toString</b></a></td><td><a href="class129667.html#refclass129667"><b>LabelSymbol</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129027.html#refoperation134019"><b>toString</b></a></td><td><a href="class129027.html#refclass129027"><b>Operand3a</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128259.html#refoperation128515"><b>toString</b></a></td><td><a href="class128259.html#refclass128259"><b>Type</b></a></td><td>Returns a printable representation of the type expression. Must be<br />overridden by subclasses.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128259.html#refoperation128131"><b>Type</b></a></td><td><a href="class128259.html#refclass128259"><b>Type</b></a></td><td>Constructor for a simple type name().</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation158723"><b>type</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "type"<br /> ./src/VSLParser.g:38:1: type : ( INT_KW ^| VOID_KW ^);</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation164483"><b>type</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> $ANTLR end "proto"<br /> $ANTLR start "type"<br /> ./src/VSLTreeParser.g:71:1: type returns [Type type] : ( INT_KW | VOID_KW );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation157955"><b>unit</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> $ANTLR start "unit"<br /> ./src/VSLParser.g:25:1: unit : ( function | proto );</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129795.html#refoperation136323"><b>unknownIdentifier</b></a></td><td><a href="class129795.html#refclass129795"><b>Errors</b></a></td><td>Error message for an unknown identifier (i.e., use before declaration).<br /><br />@param token<br />           ANTLR token (for line/column numbering).<br />@param name<br />           name of the undeclared identifier.<br />@param extra<br />           additional information to the error message, or null if none.</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130947.html#refoperation150531"><b>VarSymbol</b></a></td><td><a href="class130947.html#refclass130947"><b>VarSymbol</b></a></td><td>Constructor for temporary integer variables (scope is meaningless).<br /><br />@param n<br />           string: name of the id</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130947.html#refoperation150403"><b>VarSymbol</b></a></td><td><a href="class130947.html#refclass130947"><b>VarSymbol</b></a></td><td>Generic constructor<br /><br />@param t<br />           type (INT or ARRAY)<br />@param n<br />           string: name of the symbol<br />@param sc<br />           int: declaration scope level</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation151555"><b>VSLLexer</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation151683"><b>VSLLexer</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131587.html#refoperation151427"><b>VSLLexer</b></a></td><td><a href="class131587.html#refclass131587"><b>VSLLexer</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation156547"><b>VSLParser</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td> delegators</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131843.html#refoperation156675"><b>VSLParser</b></a></td><td><a href="class131843.html#refclass131843"><b>VSLParser</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation163459"><b>VSLTreeParser</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135171.html#refoperation163331"><b>VSLTreeParser</b></a></td><td><a href="class135171.html#refclass135171"><b>VSLTreeParser</b></a></td><td> delegators</td></tr>
</table>
</body>
</html>
